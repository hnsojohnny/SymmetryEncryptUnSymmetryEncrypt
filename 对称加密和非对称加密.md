## 对称加密

原数据根据密钥进行加密算法后形成一个密文，然后另一端根据密钥进行解密算法之后得到原数据。
> 其中密钥一定要是要保密的。

## 非对称加密
原数据根据公钥进行加密形成密文，然后另一端根据私钥进行解密得到原数据。

### 对称加密缺点:
    >   由于两端需要传输密钥，有可能密钥会让第三方劫持到。

## 数字签名
 
 ### 数字签名衍化过程
 原来数据根据私钥进行加密算法后，得到签名数据，然后根据公钥加密算法得到原数据。

 >  由原来的公钥进行加密算法变成用私钥进行加密算法。
 
原数据 ---> 私钥加密 ——> 签名数据 ---> 公钥加密 ——> 原数据

>   由于原数据使用了私钥签名，所以签名数据不容易伪造。

但是另一端接受的时候不知道是不是原数据，所以还要把原数据附加一起发送给另一端，这样另一端把签名数据解密后得到的数据和原数据进行比较，如果一样就表示得到了原数据。

原数据 ---> 私钥加密 ——> 签名数据+原数据 ---> 公钥加密 ——> 原数据+原数据

>   非对称加密防止中间人看到数据，而数字签名则保证了消息不可伪造。所以最好的办法是：非对称加密+签名才是最好的加密。

所以上面那种方式附带原数据发送给另一端，可以先对原数据进行非对称加密，发送给另一端，这样就能保证原数据中间人偷窥不了。

A ---> B的公钥加密 + A的私钥加密 ——> 密文 + 签名数据 --> B的私钥解密+A的公钥解密 ——> B(原数据+原数据)

但是由于签名数据根据A的私钥加密，所以签名数据可以根据A的公钥进行解密，这样中间人可以拿到原数据。并且原数据发送了两遍这样也会造成数据臃肿，所以我们需要对签名数据进行处理，使用原数据进行一次hash之后得到摘要，然后根据私钥对摘要数据进行签名，这样，就算利用公钥解密也不会得到原数据，而是得到摘要数据。

A ---> B的公钥加密 + 数据进行hash得到的摘要进行签名 ——> 密文+签名摘要数据 ---> B的私钥解密+A的公钥进行摘要解密 ——> B(原数据+摘要)

最后对原数据进行一次hash后得到的摘要和解密后的摘要进行对比就可以了，这样既防止不会拿到原数据，又能防止数据臃肿。